import numpy as np


class DoomSampler():

    def __init__(self):
        import DoomLevelsGAN.DoomGAN as Gan
        import WAD_Parser.WADFeatureExtractor as fe

        self.gan = Gan.gan
        self.extractor = fe.WADFeatureExtractor()
        self.last_generated_samples = None

    def get_features_of(self, input_noise, input_features):
        """
        Gets the list of features computed from the samples generated by input_noise and input_features.
        :param input_noise: Generation noise. Must be an array of shape (batch_size [32], z_dim [100])
        :param input_features: Input features for the conditional network. Must be an array of shape (batch_size [32], n_input_features)
        :return: A dictionary containing feature names as key and the list of feature values (of length batch_size) as values
        """
        assert input_noise.shape == (self.gan.config.batch_size, self.gan.config.z_dim), \
            "Input Noise must have shape (batch_size, z_dim), which is ({},{})".format(
                self.gan.config.batch_size, self.gan.config.z_dim)
        if self.gan.use_features:
            assert input_features.shape == (self.gan.config.batch_size, len(self.gan.features)), \
                "Input Features must have shape (batch_size, n_features), which is ({},{})".format(self.gan.config.batch_size, len(self.gan.features))
        temp_features = list()
        out_features = dict()
        self.gan.initialize_and_restore()

        # Associating map names to sample indices
        fm_idx = self.gan.maps.index("floormap")
        wm_idx = self.gan.maps.index("wallmap")
        tm_idx = self.gan.maps.index("thingsmap")

        self.last_generated_samples = self.gan.sample(mode='direct', y_batch=input_features, z_override=input_noise, postprocess=True).astype(np.uint8)
        for s in self.last_generated_samples[:,...]:
            temp_features.append(self.extractor.extract_features_from_maps(s[:,...,fm_idx], s[:,...,wm_idx], s[:,...,tm_idx]))

        # Converting list of dicts to dict of lists
        for feat_samp in temp_features:
            for feature in feat_samp:
                if feature not in out_features:
                    out_features[feature] = []
                out_features[feature].append(feat_samp[feature])
        return out_features


def example():
    """
    Example of code returning features for 32 generated levels
    """
    sampler = DoomSampler()
    # Current architecture works on batches of 32 levels
    # Noise shape is (batch_size, 100)
    noise_shape = [32, 100]
    # Input Feature vector shape is (batch_size, 7) - Refer to DoomLevelsGAN/network_architecture.py
    feat_shape = [32, 7]

    # Generating random noise and input features as example
    noise = np.random.random(size=noise_shape)
    input_features = np.random.random(size=feat_shape)
    out_features = sampler.get_features_of(noise, input_features)

    # Retrieving samples
    levels = sampler.last_generated_samples

    # Printing feature values
    for f_name, f_list in out_features.items():
        print("Feature: {} \n {}".format(f_name, f_list))
